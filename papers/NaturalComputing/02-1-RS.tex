% !TEX root =  ./main.tex

\subsection{Reaction Systems with Guarded Contexts}

First, we briefly account for the classical set theoretic definition of Reaction Systems (RSs)~\cite{DBLP:journals/fuin/EhrenfeuchtR07}. Then, we focus on their process algebraic version~\cite{DBLP:journals/tcs/BrodoBF21} and its further extension with guarded contexts in~\cite{DBLP:conf/cmsb/BowlesBBFGM24}.


\medskip
\noindent
\textbf{RS basics.}
A Reaction System~\cite{DBLP:journals/fuin/EhrenfeuchtR07} is a pair ${\cal A} = (S, A)$, where $S$ is the finite set of \emph{entities}, and $A$ is a finite set of \emph{reactions}, i.e., triples of the form $a = (R,I,P)$, where $R, I, P\subseteq S$ and $R \cap I = \emptyset$. 
The sets $R, I, P$ are the sets of \emph{reactants}, \emph{inhibitors}, and  \emph{products}, respectively. 
Without loss of generality, we admit the use of empty sets as reactants or inhibitors.
%
Given the current state $W\subseteq S$, a reaction $a = (R,I,P)$ is enabled in $W$ if all its reactants are present (i.e., $R\subseteq W$) and all its inhibitors absent (i.e., $W \cap I = \emptyset$).
The \emph{result} of the reaction $a$ on the current state $W$ is defined by letting
$
\mathit{res}_a(W) \triangleq\;
P$ if $a$ is enabled, and
$\mathit{res}_a(W) \triangleq\; \emptyset$ otherwise.
The result of all reactions $A$ on the current state $W$, is $\mathit{res}_A(W) \triangleq \cup_{a \in A} \mathit{res}_a(W)$.

The no-permanency principle of RSs dictates that entities disappear if not sustained by some reaction.
Thus, the current state $W=D\cup C$ is determined by the result $D$ of all reactions on the previous state, together with additional entities $C$ provided by the \emph{context}. 

\medskip
\noindent
\textbf{Process algebraic RSs and guarded contexts.}
Inspired by Plotkin's Structural Operational Semantics (SOS) approach~\cite{DBLP:journals/jlp/Plotkin04a} and process algebras such as CCS~\cite{Milner80}, the key features of the process algebraic version of RSs, are the ability to account for a quite general notion of context (guarded, nondeterministic, recursive) using a friendly syntax and a compositional approach. This way, we derive a Labelled Transition System (LTS) semantics for RSs by means of inductive inference rules, where LTS states are terms of an algebra, each transition defines a computation step of the RS and its label records the entities involved in that step.

\begin{definition}[RS processes]\label{def:LTSforRS}
%Let $S$ be a set of entities. 
\emph{RS processes} are defined by the grammar below:

\begin{eqnarray*}
\mathsf{P} & := & [\mathsf{M}]
\\
\mathsf{M} & := & (R,I,P) \mid D \mid \mathsf{K} \mid \mathsf{M}|\mathsf{M}
\\
\mathsf{K} & ::= & \nil \mid (R,I,C).\mathsf{K} \mid \mathsf{K}+\mathsf{K} \mid X
\end{eqnarray*}

\noindent
where $R$, $I$, $P$, $C$, and $D$ are sets of entities (with $P\neq \emptyset$ and $R\cap I=\emptyset$) and $X$ is a context identifier drawn from a family of (recursive) definitions $\Delta \triangleq\{X_j=\mathsf{K}_j\}_{j\in J}$, called the \emph{environment}.
\end{definition}

Roughly, a RS process  $\mathsf{P}$ embeds a \emph{mixture} process $\mathsf{M}$ obtained as the parallel composition of some reactions $(R,I,P)$, some available entities $D$ (if any), and some \emph{context} process $\mathsf{K}$.
%We write $\prod_{i\in I} \mathsf{M}_i$ for the parallel composition of all $\mathsf{M}_i$ with $i\in I$. 
A  context process $\mathsf{K}$ is either: 
the nil context $\nil$ that stops the computation;
the guarded context $(R,I,C).\mathsf{K}$ that makes the entities $C$ available to the reactions if the reactants $R$ are present and the inhibitors $I$ are absent, and then will behave as $\mathsf{K}$ at the next step;
the non-deterministic choice $\mathsf{K}_1+\mathsf{K}_2$ that can behave as either  $\mathsf{K}_1$ or $\mathsf{K}_2$;  
the context identifier $X$ that behaves as $\mathsf{K}$ for $X=\mathsf{K}\in \Delta$.
We write $C.\mathsf{K}$ as a shorthand for the trivially guarded process $(\emptyset,\emptyset,C).\mathsf{K}$.


We say that $\mathsf{P}$ and $\mathsf{P}'$ are structurally equivalent, written $\mathsf{P} \equiv \mathsf{P}'$, when they denote the same term up to the laws of Abelian monoids (unit, associativity and commutativity) for  parallel composition $\cdot | \cdot$, with $\emptyset$ as the unit, and the laws of idempotent Abelian monoids for choice $\cdot +\cdot$, with $\nil$ as the unit. We also assume $D_1 | D_2 \equiv D_1\cup D_2$ for any $D_1,D_2\subseteq S$.

The SOS semantics of  RS processes is defined by the SOS rules in Fig.~\ref{fig:guardforRS2nd}.
A transition label $\ell$, written $\obs{\obs{D}{R',I',C}}{R,I,P}$, records:
the available entities $D$; the entities $C$ provided by the guarded contexts, assuming all entities in $R'$ are present and those in $I'$ are absent;
the set $R$ of entities whose presence enables or disables some reactions;
the set $I$ of entities whose absence  enables or disables some reactions;
and the set $P$ of reaction products.
The  rules guarantee that, whenever $\mathsf{P}\xrightarrow{\obs{\obs{D}{R',I',C}}{R,I,P}} \mathsf{P}'$, it holds that $(R',I',C)$ is enabled in $D$ and that
$(R,I,P)$ is enabled in $W\triangleq (D\cup C)$.

\begin{figure*}[t]
		$$  
		\infer[(\textit{\scriptsize{Ent}})]
		{D \xrightarrow{\obs{\obs{D}{\emptyset,\emptyset,\emptyset}}{\emptyset,\emptyset,\emptyset}}\emptyset}
		{}
		\qquad
		\infer[(\textit{\scriptsize{Cxt}})]
		{(R,I,C).\mathsf{K} \xrightarrow{\obs{\obs{\emptyset}{R,I,C}}{\emptyset,\emptyset,\emptyset}}\mathsf{K}}{}
		$$
		$$
		\infer[(\textit{\scriptsize Suml})]
		{\mathsf{K}_1 + \mathsf{K}_2 \xrightarrow{\ell}\mathsf{K}'_1}
		{\mathsf{K}_1 \xrightarrow{\ell}\mathsf{K}'_1}
		\qquad
		\infer[(\textit{\scriptsize Sumr})]
		{\mathsf{K}_1 + \mathsf{K}_2 \xrightarrow{\ell}\mathsf{K}'_2}
		{\mathsf{K}_2 \xrightarrow{\ell}\mathsf{K}'_2}
		\qquad
		\infer[(\textit{\scriptsize Rec})]
		{X \xrightarrow{\ell}\mathsf{K}'}
		{X=\mathsf{K}\in\Delta & \mathsf{K} \xrightarrow{\ell}\mathsf{K}'}
		$$
		$$
		\infer[(\textit{\scriptsize Pro})]
		{(R,I,P)  \xrightarrow{\obs{\obs{\emptyset}{\emptyset,\emptyset,\emptyset}}{R,I,P}}(R,I,P)|P}
		{}
		\qquad
		\infer[(\textit{\scriptsize Inh})]
		{(R,I,P)  \xrightarrow{\obs{\obs{\emptyset}{\emptyset,\emptyset,\emptyset}}{J,Q,\emptyset}}(R,I,P)}
		{J \subseteq I & Q \subseteq R & J\cup Q\neq \emptyset}
		$$
		$$
		\infer[(\textit{\scriptsize Par})]
		{\mathsf{M}_1~|~\mathsf{M}_2\xrightarrow{\ell_1\cup\ell_2} \mathsf{M}'_1~|~\mathsf{M}'_2}
		{\mathsf{M}_1 \xrightarrow{\ell_1} \mathsf{M}'_1 &
		\mathsf{M}_2 \xrightarrow{\ell_2} \mathsf{M}'_2 &
			\ell_1\frown \ell_2 }
		\qquad
		\infer[(\textit{\scriptsize Sys})]
		{[\mathsf{M}]\xrightarrow{\obs{\obs{D}{R',I',C}}{R,I,P}} [\mathsf{M}']}
		{\mathsf{M}\xrightarrow{\obs{\obs{D}{R',I',C}}{R,I,P}} \mathsf{M}' &
		R'\subseteq D &
        R\subseteq D\cup C}
		$$
		
\noindent
		where $\ell_1 \frown \ell_2$ and $\ell_1 \cup \ell_2$ are defined as follows:
		
		$$\begin{array}{l}
\obs{\obs{D_1}{R'_1,I'_1,C_1}}{R_1,I_1,P_1}
\frown
\obs{\obs{D_2}{R'_2,I'_2,C_2}}{R_2,I_2,P_2}
\\
\qquad\qquad\qquad\qquad\qquad\qquad
\triangleq (\textstyle\bigcup_{i=1,2} D_i\cup  R'_i) \cap (I'_1 \cup I'_2) = \emptyset
\wedge
(\bigcup_{i=1,2} D_i\cup  C_i\cup  R_i) \cap (I_1 \cup I_2) = \emptyset \\[5pt]
\obs{\obs{D_1}{R'_1,I'_1,C_1}}{R_1,I_1,P_1}
\cup
\obs{\obs{D_2}{R'_2,I'_2,C_2}}{R_2,I_2,P_2}
\\
\qquad\qquad\qquad\qquad\qquad\qquad
\triangleq \obs{\obs{D_1\cup D_2}{R'_1\cup R'_2,I'_1\cup I'_2,C_1\cup C_2}}{R_1\cup R_2,I_1\cup I_2,P_1\cup P_2}
\end{array}$$
		\caption{SOS semantics of the RS processes.}
		\label{fig:guardforRS2nd}
\end{figure*}


The rule $(\textit{Ent})$ records the set of current entities $D$.
By rule $(\textit{Cxt})$, a prefixed context process $C.\mathsf{K}$ makes available the entities in $C$ and then reduces to $\mathsf{K}$. 
Rules $(\textit{Suml})$ and $(\textit{Sumr})$ select a move of either the left or the right context, resp., discarding the other process.
By rule $(\textit{Rec})$, a context identifier $X$ behaves according to its defining process $\mathsf{K}$.
The rule $(\textit{Pro})$ assumes the reaction $(R,I,P)$ is enabled: it records its reactants, inhibitors, and products in the label, and leaves the reaction  available at the next step, together with its products $P$.
The rule $(\textit{Inh})$ records in the label the reasons why the reaction $(R,I,P)$ should not be executed: possibly some inhibiting entities $(J \subseteq I)$ are present or some reactants $(Q \subseteq R)$ are missing, with $J \cup Q \neq \emptyset$, as at least one cause is needed.
The rule $(\textit{Par})$ puts two processes in parallel by pooling their labels and joining all labels components. We write $\ell_1\cup\ell_2$ for the component-wise union of labels:
%
{\footnotesize
\[
%\begin{array}{l}
\textstyle
\bigcup_{i=1,2} \obs{(D_i,C_i)}{R_i,I_i,P_i}
%\obs{(D_1,C_1)}{R_1,I_1,P_1}
%\cup
%\obs{(D_2,C_2)}{R_2,I_2,P_2}\\
%\hspace{4.8cm}
\triangleq 
\obs{(D_1\cup D_2,C_1\cup C_2)}{R_1\cup R_2,I_1\cup I_2,P_1\cup P_2}\ .
%\end{array}
\]}


The sanity check $\ell_1\frown\ell_2$ is required to guarantee that labels of reactants and inhibitors are consistent (see definition below):
%
{\footnotesize
\[
%\begin{array}{l}
\obs{(D_1,C_1)}{R_1,I_1,P_1}
\frown
\obs{(D_2,C_2)}{R_2,I_2,P_2}
\triangleq
\textstyle (\bigcup_{i=1,2} D_i\cup C_i \cup R_i) \cap (I_1\cup I_2) = \emptyset .
%\\
%\hspace{5cm}\triangleq 
%(D_1\cup  D_2 \cup C_1 \cup C_2 \cup R_1 \cup R_2) \cap (I_1 \cup I_2) = \emptyset\ .
%\end{array}
\]
}


Finally, the rule $(\textit{Sys})$ checks that all the needed reactants are available in the system ($R \subseteq D\cup C$). Checking the absence of inhibitors  ($(D\cup C)\cap I = \emptyset$) is not necessary, thanks to the sanity check in rule $(\textit{Par})$.
%
%In the following we assume transitions $\mathsf{P}\xrightarrow{\obs{(D,C)}{R,I,P}} \mathsf{P}'$ guarantee that any instance of the rule $(\textit{Inh})$ is applied in a way that maximizes the sets $J$ and $Q$ (see~\cite{DBLP:journals/tcs/BrodoBF21}).
Notably, the SOS semantics matches the set-theoretic dynamics of RSs (as made precise by~\cite[Th.~19]{DBLP:journals/tcs/BrodoBF21}). 


%\begin{theorem}[cf.~\cite{DBLP:journals/tcs/BrodoBF21}]
%\label{the:corr}
%Let ${\cal A}$  be a RS, let $\pi=(\{C_i\}_{i\in[0,n]},\{D_i\}_{i\in[0,n]})$ an interactive process, and let
%$\mathsf{P}_i \triangleq \llbracket {\cal A},\pi \rrbracket_i$ for any $i\in[0,n]$.
%Then, for any $i\in[0,n-1]$:
%%both the following conditions hold:
%\begin{enumerate}
%\item
%if $\mathsf{P}_i \xrightarrow{\obs{(D,C)}{R,I,P}} \mathsf{P}$
% then
%$D=D_i$, $C=C_i$, $P= D_{i+1}$ and
%$\mathsf{P} \equiv \mathsf{P}_{i+1}$;
%\item there exists
%$R,I \subseteq S$ such that 
%$\mathsf{P}_i \xrightarrow{\obs{(D_i,C_i)}{R,I,D_{i+1}}} \mathsf{P}_{i+1}$.
%\end{enumerate}
%\end{theorem}


The similarity with the syntax of reactions is intended: the key difference is that in $(R,I,C).\mathsf{K}$ the presence of reactants $R$ and the absence of inhibitors $I$ is checked w.r.t. the set of current entities $D$.
More importantly, the products $C$ are made available immediately from the context, not at the next step.
Note that a conditional prefixed process that is not enabled behaves as the $\nil$ process.





\begin{example}
The context 
\(
X = (\{\mathsf{a}\},\emptyset,\{\mathsf{b}\}).X + (\{\mathsf{b}\},\emptyset,\{\mathsf{a}\}).X + (\emptyset,\{\mathsf{a},\mathsf{b}\},\emptyset).X
\)
%\noindent
ensures that whenever $\mathsf{a}$ or $\mathsf{b}$ are present in the current state, then both $\mathsf{a}$ and $\mathsf{b}$ are available as reactants.
The last option $(\emptyset,\{\mathsf{a},\mathsf{b}\},\emptyset).X$ handles the case where the first two guards fail: if omitted, when both $\mathsf{a}$ and $\mathsf{b}$ are absent the context $X$ would behave as $\nil$, blocking the computation.
\end{example}
