% !TEX root =  ./main.tex

\section{Encoding of RS in GT}\label{sec:RS2GTS}

Instead of BioResolve, we can alternatively use graph transformation to generate the underlying LTS of a given Reaction System, on the basis of a start graph (plus dedicated specialised type graph) obtained by transformation from the RS specification. What's more, we can analyse the outcome by building the \emph{occurrence graph} of a given trace, which contains all the rule occurrences and entity instances present in that trace --- anaogous, in fact, to the way a Petri net process captures a particular behaviour of a Petri Net. Moreover, if a trace leads to the state in which an undesirable entity is present (for instance, the $\anger$ entity in our toy example), we can also \emph{prune} the occurrence graph, again using graph transformation, to filter those rule occurrences and entity instances that directly contributed to the existence of the undesirable entity.

This gives rise to the tool chain depicted in \Cref{fig:chain}, the phases of which will be explained in some more detail in the remainder of this section.	

\begin{figure}
\centering
\includegraphics[scale=.25]{figs/chain}
\caption{Reaction System exploration and analysis using \GROOVE}
\label{fig:chain}
\end{figure}

\medskip\noindent\textbf{Transform.}
%
The first step is a text-to-model transformation from a problem specification in \BioResolve syntax into \GROOVE syntax. It produces two artifacts: firstly, an additional type graph, on top of the onee shown in \Cref{fig:core-type}, in which all entities in the problem at hand are provided with their own type (essentially for performance reasons: it speeds up the matching step of \GROOVE); and secondly (more importantly) a start graph in which the entire BioResolve system is encoded as suggested by \Cref{fig:core-type}. For the example system, the additional types as well as two fragments of the start graph are shown in \Cref{fig:toy}.

\begin{figure}
\centering
\subcaptionbox{Specialised entity types}{\includegraphics[scale=.2]{figs/toy-type}}
\subcaptionbox{Start graph fragment: Three of the reactions}{\includegraphics[scale=.2]{figs/toy-reactions}}
\subcaptionbox{Start graph fragment: The \textsf{Student} context process}{\includegraphics[scale=.2]{figs/toy-context-named}}
\caption{Graph representation of running example}
\label{fig:toy}
\end{figure}

\medskip\noindent\textbf{Explore.}
%
The reaction system semantics is encoded as a combination of two rules, \contextR and \reactR, which are scheduled to fire in alternation: \contextR encodes the simultaneous firing of all context processes (involving a nondeterministically selected enabled \Step from every \State with a \Token), and \reactR encodes the simultaneous firing of all enabled \Reaction{}s, while simultaneously erasing all \Entity{}s that were not just produced. The production or erasue of an \Entity is encoded through the creation or deletion of a \present flag on a (persistent) \Entity node, \emph{not} by the creation or deletion of the node itself. In addition, to keep track of which nondeterministic choices were actually taken, the \contextR rule marks the \Step{}s that were selected with a \fired flag, which is erased by the reaction rule; a third rule called \firedR (actually a \emph{condition}, which in \GROOVE is a rule that does not modify the graph) checks for the occurrences of the \fired flag and so exposes the names of the \Rule{}s that have fired in the transition system.

\begin{figure}
\centering
\includegraphics[scale=.2]{figs/context}
\caption{Rule for context firing}
\label{fig:context}
\end{figure}
%
\Cref{fig:context} shows the first (and most intricate) of these rules, viz.\ the one for the context firing. This is a quantified rule, that can be read as follows. \uline{For all} \State{}s with a \Token, \uline{there is} a \nextt{} \Step such that \uline{for all} \inhibitor{}s \uline{there is no} \present flag whereas \uline{for all} \reactant{}s \uline{there is} a \present flag; moreover, \uline{all} \product{}s of that \Step receive a \present flag; and finally, the \Step receive a \fired flag and the \Token moves to its successor.

\GROOVE can be set generate the entire state space, which is essentially the same as the one produced by BioResolve (see \Cref{fig:toylts}), but it can also be asked to search the for the first reachable state in which an undesirable entity appears, using breadt-first search (in our running example, the \anger\todo{or \Forbidden} entity). (In fact, the pattern for which \GROOVE searches is itself determined by a rule, which in this case tests for the presence of \anger). When found, the trace to the undesirable state can be saved as a \emph{control program} that drives the next stage of \GROOVE exploration. In particular, besides the alternating application of the \contextR and \reactR rule --- the core of the Reaction System semantics --- this control program records the \firedR-applications that tell which \Step{}s have fired: this completely determines how the non-determinism in the context process has been resolved in order to arrive at the undesirable state. Here is the control program for our running example:

\begin{center}
\begin{lstlisting}[basicstyle=\sffamily\small,columns=fullflexible,xleftmargin=1cm]
context;
fired("student_2");
fired("refill_1");
react;
context;
fired("student_1");
fired("refill_0");
react;
context;
fired("refill_1");
fired("getcappuccino_1");
react;
\end{lstlisting}
\end{center}
%
Here \textsf{student\_2}, \textsf{student\_1} and \textsf{getcappucino\_1} are the \Step{}s of the \textsf{Student} process visualised in \Cref{fig:toy}; \textsf{refill\_1} and \textsf{refill\_0} are the steps of the \textsf{Refill} process given in \Cref{sec:student}.

\medskip\noindent\textbf{Build.}
%
The purpose of this phase is to build an occurrence graph that explains how the undesirable entity can become present, by collecting the (transitive) dependencies of the undesirable \anger entity. Concretely, we record the following dependencies:\todo{Refer to literature}
\begin{itemize}
\item From each non-initial \Entity instance to the \Rule occurrence of which it is the \product;
\item From each \Rule occurrence to all its reactant \Entity instances;
\item From each \Rule occurrence to all directly preceding \Step occurrences.
\end{itemize}
%
Note that this is restricted to \emph{positive} dependencies. The representaton of negative dependencies is a research question in its own, and its resultuion is outside the scope of this paper;\todo{Refer to literature} \Cref{fig:occur-type} shows the occurrence type graph. 

\begin{figure}
\centering
\includegraphics[scale=.2]{figs/occur-type}
\caption{Occurrence type graph}
\label{fig:occur-type}
\end{figure}

As indicated in \Cref{fig:chain}, the occurrence graph is produced by another \GROOVE rule system, using the same start graph but driven by the control program previously created by the explore phase, which encodes the trace to the undesirable state. The occurence graph semantics consists of rules with the same names (\reactR, \contextR and \firedR), but different functionality: in particular, rather than manipulating \present flags, the \reactR rule now creates \RuleOcc- and \EntityInst-nodes together with their dependencies. This is a non-trivial procedure that in fact itself requires several successive stages. Though the details of these stages are not of sufficient interest to include in this paper, we want to point out that breakdown of a single rule (\reactR) into multiple stages is opposed to the usual view, is engrained algebraic graph transformation, that a rule embodies a single, atomic change to a graph. This contradiction is solved by another feature of \GROOVE, namely \emph{recipes}. A recipe is a procedural control abstraction that has transactional semantics, and hence for the purpose of exploration acts just like an atomic rule; however, its body may consist of an arbitrary control (sub-)program. In the occurrence graph semantics, therrefore, \reactR is actually not a rule but a recipe, defined as

\begin{center}
\begin{lstlisting}[basicstyle=\sffamily\small,columns=fullflexible,xleftmargin=1cm,keywords={recipe},literate={-}{-}1]
recipe react() {
  entities-age;
  react-produce;
  merge;
}
\end{lstlisting}
\end{center}
%

\medskip\noindent\textbf{Prune.}
%
Unfortunately, the occurernce graph built by this rule system is too large to be usefule: it shows \emph{all} entities and rule occurrences produced by the trace, not just the dependencies of the undesired entity. Moreover, the entire start graph is also (still) present. Therefore, in a third stage, all redundant information is pruned. This is achieved by first marking all backard dependencies of the undesired entity, and then removing all unmarked nodes. Since it is straightforward, and of no particular interest in the context of this paper, we omit the details of the \GROOVE rule system for this. The oucome of this process for our running example is shown in \Cref{fig:toy-pruned}.


\begin{figure}
\centering
\includegraphics[scale=.12]{figs/toy-pruned}
\caption{Pruned occurrence graph of the running example}
\label{fig:toy-pruned}
\end{figure}



\begin{quote}\it Notes:
\begin{itemize}
\item Rules for implementing RS semantics
\item Conversion of a trace to a control program
\item Using recipes in the occurrence graph building
\end{itemize}
\end{quote}